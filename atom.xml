<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Maruku's Blog]]></title>
  <link href="http://marukulau.github.io/atom.xml" rel="self"/>
  <link href="http://marukulau.github.io/"/>
  <updated>2014-03-22T10:51:43+08:00</updated>
  <id>http://marukulau.github.io/</id>
  <author>
    <name><![CDATA[Maruku Lau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[自定义UITextField背景]]></title>
    <link href="http://marukulau.github.io/blog/2013/04/10/zi-ding-yi-uitextfieldbei-jing/"/>
    <updated>2013-04-10T10:59:00+08:00</updated>
    <id>http://marukulau.github.io/blog/2013/04/10/zi-ding-yi-uitextfieldbei-jing</id>
    <content type="html"><![CDATA[<h2>设置背景图片</h2>

<figure class='code'><figcaption><span>Code</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">UIImage</span> <span class="o">*</span><span class="n">textFieldBgImage</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIImage</span> <span class="nl">imageNamed:</span><span class="s">@&quot;textfield_bg.png&quot;</span><span class="p">]</span> <span class="nl">stretchableImageWithLeftCapWidth:</span><span class="mi">5</span> <span class="nl">topCapHeight:</span><span class="mi">5</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">textField</span> <span class="nl">setBackground:</span><span class="n">textFieldBgImage</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<!-- more -->


<h2>修改文字边距</h2>

<p>设置好图片后输入文字会发现左边的文字和背景图片的边框重叠了，需要设置一下文本框的边距，可是UITextField没有相应的属性可以设置，所以只有重写UITextField的相关方法。</p>

<figure class='code'><figcaption><span>Code</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@implementation</span> <span class="nc">UITextField</span><span class="nl">(UITextFieldCategory)</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">CGRect</span><span class="p">)</span><span class="nf">textRectForBounds:</span><span class="p">(</span><span class="n">CGRect</span><span class="p">)</span><span class="nv">bounds</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CGRect</span> <span class="n">inset</span> <span class="o">=</span> <span class="n">CGRectInset</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">inset</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">CGRect</span><span class="p">)</span><span class="nf">editingRectForBounds:</span><span class="p">(</span><span class="n">CGRect</span><span class="p">)</span><span class="nv">bounds</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CGRect</span> <span class="n">inset</span> <span class="o">=</span> <span class="n">CGRectInset</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">inset</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面偷了个懒，直接用category的方式重写了这个两个方法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[.net的DateTime时间格式转成NSDate]]></title>
    <link href="http://marukulau.github.io/blog/2013/04/10/dot-netde-datetimeshi-jian-ge-shi-zhuan-cheng-nsdate/"/>
    <updated>2013-04-10T10:20:00+08:00</updated>
    <id>http://marukulau.github.io/blog/2013/04/10/dot-netde-datetimeshi-jian-ge-shi-zhuan-cheng-nsdate</id>
    <content type="html"><![CDATA[<p>最近项目中用到的接口是.net写的，传过来的日期格式是 2013-04-10T10:36:48.787359+08:00 , 这么一大串想解析成NSDate格式还真不是一件容易的事，幸好已经有人把转换类写出来了。</p>

<!-- more -->


<h2>转换类</h2>

<p>老外写的转换类，地址不记得了，直接上代码</p>

<pre><code> /*ISO8601DateFormatter.h
 *
 *Created by Peter Hosey on 2009-04-11.
 *Copyright 2009 Peter Hosey. All rights reserved.
 */

#import &lt;Foundation/Foundation.h&gt;

/*This class converts dates to and from ISO 8601 strings. A good introduction to ISO 8601: &lt;http://www.cl.cam.ac.uk/~mgk25/iso-time.html&gt;
 *
 *Parsing can be done strictly, or not. When you parse loosely, leading whitespace is ignored, as is anything after the date.
 *The loose parser will return an NSDate for this string: @" \t\r\n\f\t  2006-03-02!!!"
 *Leading non-whitespace will not be ignored; the string will be rejected, and nil returned. See the README that came with this addition.
 *
 *The strict parser will only accept a string if the date is the entire string. The above string would be rejected immediately, solely on these grounds.
 *Also, the loose parser provides some extensions that the strict parser doesn't.
 *For example, the standard says for "-DDD" (an ordinal date in the implied year) that the logical representation (meaning, hierarchically) would be "--DDD", but because that extra hyphen is "superfluous", it was omitted.
 *The loose parser will accept the extra hyphen; the strict parser will not.
 *A full list of these extensions is in the README file.
 */

/*The format to either expect or produce.
 *Calendar format is YYYY-MM-DD.
 *Ordinal format is YYYY-DDD, where DDD ranges from 1 to 366; for example, 2009-32 is 2009-02-01.
 *Week format is YYYY-Www-D, where ww ranges from 1 to 53 (the 'W' is literal) and D ranges from 1 to 7; for example, 2009-W05-07.
 */
enum {
    ISO8601DateFormatCalendar,
    ISO8601DateFormatOrdinal,
    ISO8601DateFormatWeek,
};
typedef NSUInteger ISO8601DateFormat;

//The default separator for time values. Currently, this is ':'.
extern unichar ISO8601DefaultTimeSeparatorCharacter;

@interface ISO8601DateFormatter: NSFormatter
{
    NSString *lastUsedFormatString;
    NSDateFormatter *unparsingFormatter;

    NSCalendar *parsingCalendar, *unparsingCalendar;

    NSTimeZone *defaultTimeZone;
    ISO8601DateFormat format;
    unichar timeSeparator;
    BOOL includeTime;
    BOOL parsesStrictly;
}

//Call this if you get a memory warning.
+ (void) purgeGlobalCaches;

@property(nonatomic, retain) NSTimeZone *defaultTimeZone;

#pragma mark Parsing

//As a formatter, this object converts strings to dates.

@property BOOL parsesStrictly;

- (NSDateComponents *) dateComponentsFromString:(NSString *)string;
- (NSDateComponents *) dateComponentsFromString:(NSString *)string timeZone:(out NSTimeZone **)outTimeZone;
- (NSDateComponents *) dateComponentsFromString:(NSString *)string timeZone:(out NSTimeZone **)outTimeZone range:(out NSRange *)outRange;

- (NSDate *) dateFromString:(NSString *)string;
- (NSDate *) dateFromString:(NSString *)string timeZone:(out NSTimeZone **)outTimeZone;
- (NSDate *) dateFromString:(NSString *)string timeZone:(out NSTimeZone **)outTimeZone range:(out NSRange *)outRange;

#pragma mark Unparsing

@property ISO8601DateFormat format;
@property BOOL includeTime;
@property unichar timeSeparator;

- (NSString *) stringFromDate:(NSDate *)date;
- (NSString *) stringFromDate:(NSDate *)date timeZone:(NSTimeZone *)timeZone;

@end



/*ISO8601DateFormatter.m
 *
 *Created by Peter Hosey on 2009-04-11.
 *Copyright 2009 Peter Hosey. All rights reserved.
 */

#import &lt;Foundation/Foundation.h&gt;
#import "ISO8601DateFormatter.h"

#ifndef DEFAULT_TIME_SEPARATOR
#       define DEFAULT_TIME_SEPARATOR ':'
#endif
unichar ISO8601DefaultTimeSeparatorCharacter = DEFAULT_TIME_SEPARATOR;

//Unicode date formats.
#define ISO_CALENDAR_DATE_FORMAT @"yyyy-MM-dd"
//#define ISO_WEEK_DATE_FORMAT @"YYYY-'W'ww-ee" //Doesn't actually work because NSDateComponents counts the weekday starting at 1.
#define ISO_ORDINAL_DATE_FORMAT @"yyyy-DDD"
#define ISO_TIME_FORMAT @"HH:mm:ss"
#define ISO_TIME_WITH_TIMEZONE_FORMAT  ISO_TIME_FORMAT @"Z"
//printf formats.
#define ISO_TIMEZONE_UTC_FORMAT @"Z"
#define ISO_TIMEZONE_OFFSET_FORMAT @"%+.2d%.2d"

@interface ISO8601DateFormatter(UnparsingPrivate)

- (NSString *) replaceColonsInString:(NSString *)timeFormat withTimeSeparator:(unichar)timeSep;

- (NSString *) stringFromDate:(NSDate *)date formatString:(NSString *)dateFormat timeZone:(NSTimeZone *)timeZone;
- (NSString *) weekDateStringForDate:(NSDate *)date timeZone:(NSTimeZone *)timeZone;

@end

static NSMutableDictionary *timeZonesByOffset;

@implementation ISO8601DateFormatter

+ (void) initialize {
    if (!timeZonesByOffset) {
        timeZonesByOffset = [[NSMutableDictionary alloc] init];
    }
}

+ (void) purgeGlobalCaches {
    NSMutableDictionary *oldCache = timeZonesByOffset;
    timeZonesByOffset = nil;
    [oldCache release];
}

- (NSCalendar *) makeCalendarWithDesiredConfiguration {
    NSCalendar *calendar = [[[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar] autorelease];
    calendar.firstWeekday = 2; //Monday
    calendar.timeZone = [NSTimeZone defaultTimeZone];
    return calendar;
}

- (id) init {
    if ((self = [super init])) {
        parsingCalendar = [[self makeCalendarWithDesiredConfiguration] retain];
        unparsingCalendar = [[self makeCalendarWithDesiredConfiguration] retain];

        format = ISO8601DateFormatCalendar;
        timeSeparator = ISO8601DefaultTimeSeparatorCharacter;
        includeTime = NO;
        parsesStrictly = NO;
    }
    return self;
}
- (void) dealloc {
    [defaultTimeZone release];

    [unparsingFormatter release];
    [lastUsedFormatString release];
    [parsingCalendar release];
    [unparsingCalendar release];

    [super dealloc];
}

@synthesize defaultTimeZone;
- (void) setDefaultTimeZone:(NSTimeZone *)tz {
    if (defaultTimeZone != tz) {
        [defaultTimeZone release];
        defaultTimeZone = [tz retain];

        unparsingCalendar.timeZone = defaultTimeZone;
    }
}

//The following properties are only here because GCC doesn't like @synthesize in category implementations.

#pragma mark Parsing

@synthesize parsesStrictly;

static NSUInteger read_segment(const unsigned char *str, const unsigned char **next, NSUInteger *out_num_digits);
static NSUInteger read_segment_4digits(const unsigned char *str, const unsigned char **next, NSUInteger *out_num_digits);
static NSUInteger read_segment_2digits(const unsigned char *str, const unsigned char **next);
static double read_double(const unsigned char *str, const unsigned char **next);
static BOOL is_leap_year(NSUInteger year);

/*Valid ISO 8601 date formats:
 *
 *YYYYMMDD
 *YYYY-MM-DD
 *YYYY-MM
 *YYYY
 *YY //century
 * //Implied century: YY is 00-99
 *  YYMMDD
 *  YY-MM-DD
 * -YYMM
 * -YY-MM
 * -YY
 * //Implied year
 *  --MMDD
 *  --MM-DD
 *  --MM
 * //Implied year and month
 *   ---DD
 * //Ordinal dates: DDD is the number of the day in the year (1-366)
 *YYYYDDD
 *YYYY-DDD
 *  YYDDD
 *  YY-DDD
 *   -DDD
 * //Week-based dates: ww is the number of the week, and d is the number (1-7) of the day in the week
 *yyyyWwwd
 *yyyy-Www-d
 *yyyyWww
 *yyyy-Www
 *yyWwwd
 *yy-Www-d
 *yyWww
 *yy-Www
 * //Year of the implied decade
 *-yWwwd
 *-y-Www-d
 *-yWww
 *-y-Www
 * //Week and day of implied year
 *  -Wwwd
 *  -Www-d
 * //Week only of implied year
 *  -Www
 * //Day only of implied week
 *  -W-d
 */

- (NSDateComponents *) dateComponentsFromString:(NSString *)string {
    return [self dateComponentsFromString:string timeZone:NULL];
}
- (NSDateComponents *) dateComponentsFromString:(NSString *)string timeZone:(out NSTimeZone **)outTimeZone {
    return [self dateComponentsFromString:string timeZone:outTimeZone range:NULL];
}
- (NSDateComponents *) dateComponentsFromString:(NSString *)string timeZone:(out NSTimeZone **)outTimeZone range:(out NSRange *)outRange {
    NSDate *now = [NSDate date];

    NSDateComponents *components = [[[NSDateComponents alloc] init] autorelease];
    NSDateComponents *nowComponents = [parsingCalendar components:(NSYearCalendarUnit | NSMonthCalendarUnit | NSDayCalendarUnit) fromDate:now];

    NSUInteger
    //Date
    year,
    month_or_week = 0U,
    day = 0U,
    //Time
    hour = 0U;
    NSTimeInterval
    minute = 0.0,
    second = 0.0;
    //Time zone
    NSInteger tz_hour = 0;
    NSInteger tz_minute = 0;

    enum {
        monthAndDate,
        week,
        dateOnly
    } dateSpecification = monthAndDate;

    BOOL strict = self.parsesStrictly;
    unichar timeSep = self.timeSeparator;

    if (strict) timeSep = ISO8601DefaultTimeSeparatorCharacter;
    NSAssert(timeSep != '\0', @"Time separator must not be NUL.");

    BOOL isValidDate = ([string length] &gt; 0U);
    NSTimeZone *timeZone = nil;

    const unsigned char *ch = (const unsigned char *)[string UTF8String];

    NSRange range = { 0U, 0U };
    const unsigned char *start_of_date = NULL;
    if (strict &amp;&amp; isspace(*ch)) {
        range.location = NSNotFound;
        isValidDate = NO;
    } else {
        //Skip leading whitespace.
        NSUInteger i = 0U;
        for(NSUInteger len = strlen((const char *)ch); i &lt; len; ++i) {
            if (!isspace(ch[i]))
                break;
        }

        range.location = i;
        ch += i;
        start_of_date = ch;

        NSUInteger segment;
        NSUInteger num_leading_hyphens = 0U, num_digits = 0U;

        if (*ch == 'T') {
            //There is no date here, only a time. Set the date to now; then we'll parse the time.
            isValidDate = isdigit(*++ch);

            year = nowComponents.year;
            month_or_week = nowComponents.month;
            day = nowComponents.day;
        } else {
            while(*ch == '-') {
                ++num_leading_hyphens;
                ++ch;
            }

            segment = read_segment(ch, &amp;ch, &amp;num_digits);
            switch(num_digits) {
                case 0:
                    if (*ch == 'W') {
                        if ((ch[1] == '-') &amp;&amp; isdigit(ch[2]) &amp;&amp; ((num_leading_hyphens == 1U) || ((num_leading_hyphens == 2U) &amp;&amp; !strict))) {
                            year = nowComponents.year;
                            month_or_week = 1U;
                            ch += 2;
                            goto parseDayAfterWeek;
                        } else if (num_leading_hyphens == 1U) {
                            year = nowComponents.year;
                            goto parseWeekAndDay;
                        } else
                            isValidDate = NO;
                    } else
                        isValidDate = NO;
                    break;

                case 8: //YYYY MM DD
                    if (num_leading_hyphens &gt; 0U)
                        isValidDate = NO;
                    else {
                        day = segment % 100U;
                        segment /= 100U;
                        month_or_week = segment % 100U;
                        year = segment / 100U;
                    }
                    break;

                case 6: //YYMMDD (implicit century)
                    if (num_leading_hyphens &gt; 0U)
                        isValidDate = NO;
                    else {
                        day = segment % 100U;
                        segment /= 100U;
                        month_or_week = segment % 100U;
                        year  = nowComponents.year;
                        year -= (year % 100U);
                        year += segment / 100U;
                    }
                    break;

                case 4:
                    switch(num_leading_hyphens) {
                        case 0: //YYYY
                            year = segment;

                            if (*ch == '-') ++ch;

                            if (!isdigit(*ch)) {
                                if (*ch == 'W')
                                    goto parseWeekAndDay;
                                else
                                    month_or_week = day = 1U;
                            } else {
                                segment = read_segment(ch, &amp;ch, &amp;num_digits);
                                switch(num_digits) {
                                    case 4: //MMDD
                                        day = segment % 100U;
                                        month_or_week = segment / 100U;
                                        break;

                                    case 2: //MM
                                        month_or_week = segment;

                                        if (*ch == '-') ++ch;
                                        if (!isdigit(*ch))
                                            day = 1U;
                                        else
                                            day = read_segment(ch, &amp;ch, NULL);
                                        break;

                                    case 3: //DDD
                                        day = segment % 1000U;
                                        dateSpecification = dateOnly;
                                        if (strict &amp;&amp; (day &gt; (365U + is_leap_year(year))))
                                            isValidDate = NO;
                                        break;

                                    default:
                                        isValidDate = NO;
                                }
                            }
                            break;

                        case 1: //YYMM
                            month_or_week = segment % 100U;
                            year = segment / 100U;

                            if (*ch == '-') ++ch;
                            if (!isdigit(*ch))
                                day = 1U;
                            else
                                day = read_segment(ch, &amp;ch, NULL);

                            break;

                        case 2: //MMDD
                            day = segment % 100U;
                            month_or_week = segment / 100U;
                            year = nowComponents.year;

                            break;

                        default:
                            isValidDate = NO;
                    } //switch(num_leading_hyphens) (4 digits)
                    break;

                case 1:
                    if (strict) {
                        //Two digits only - never just one.
                        if (num_leading_hyphens == 1U) {
                            if (*ch == '-') ++ch;
                            if (*++ch == 'W') {
                                year  = nowComponents.year;
                                year -= (year % 10U);
                                year += segment;
                                goto parseWeekAndDay;
                            } else
                                isValidDate = NO;
                        } else
                            isValidDate = NO;
                        break;
                    }
                case 2:
                    switch(num_leading_hyphens) {
                        case 0:
                            if (*ch == '-') {
                                //Implicit century
                                year  = nowComponents.year;
                                year -= (year % 100U);
                                year += segment;

                                if (*++ch == 'W')
                                    goto parseWeekAndDay;
                                else if (!isdigit(*ch)) {
                                    goto centuryOnly;
                                } else {
                                    //Get month and/or date.
                                    segment = read_segment_4digits(ch, &amp;ch, &amp;num_digits);
                                    NSLog(@"(%@) parsing month; segment is %lu and ch is %s", string, (unsigned long)segment, ch);
                                    switch(num_digits) {
                                        case 4: //YY-MMDD
                                            day = segment % 100U;
                                            month_or_week = segment / 100U;
                                            break;

                                        case 1: //YY-M; YY-M-DD (extension)
                                            if (strict) {
                                                isValidDate = NO;
                                                break;
                                            }
                                        case 2: //YY-MM; YY-MM-DD
                                            month_or_week = segment;
                                            if (*ch == '-') {
                                                if (isdigit(*++ch))
                                                    day = read_segment_2digits(ch, &amp;ch);
                                                else
                                                    day = 1U;
                                            } else
                                                day = 1U;
                                            break;

                                        case 3: //Ordinal date.
                                            day = segment;
                                            dateSpecification = dateOnly;
                                            break;
                                    }
                                }
                            } else if (*ch == 'W') {
                                year  = nowComponents.year;
                                year -= (year % 100U);
                                year += segment;

                            parseWeekAndDay: //*ch should be 'W' here.
                                if (!isdigit(*++ch)) {
                                    //Not really a week-based date; just a year followed by '-W'.
                                    if (strict)
                                        isValidDate = NO;
                                    else
                                        month_or_week = day = 1U;
                                } else {
                                    month_or_week = read_segment_2digits(ch, &amp;ch);
                                    if (*ch == '-') ++ch;
                                parseDayAfterWeek:
                                    day = isdigit(*ch) ? read_segment_2digits(ch, &amp;ch) : 1U;
                                    dateSpecification = week;
                                }
                            } else {
                                //Century only. Assume current year.
                            centuryOnly:
                                year = segment * 100U + nowComponents.year % 100U;
                                month_or_week = day = 1U;
                            }
                            break;

                        case 1:; //-YY; -YY-MM (implicit century)
                            NSLog(@"(%@) found %lu digits and one hyphen, so this is either -YY or -YY-MM; segment (year) is %lu", string, (unsigned long)num_digits, (unsigned long)segment);
                            NSUInteger current_year = nowComponents.year;
                            NSUInteger current_century = (current_year % 100U);
                            year = segment + (current_year - current_century);
                            if (num_digits == 1U) //implied decade
                                year += current_century - (current_year % 10U);

                            if (*ch == '-') {
                                ++ch;
                                month_or_week = read_segment_2digits(ch, &amp;ch);
                                NSLog(@"(%@) month is %lu", string, (unsigned long)month_or_week);
                            }

                            day = 1U;
                            break;

                        case 2: //--MM; --MM-DD
                            year = nowComponents.year;
                            month_or_week = segment;
                            if (*ch == '-') {
                                ++ch;
                                day = read_segment_2digits(ch, &amp;ch);
                            }
                            break;

                        case 3: //---DD
                            year = nowComponents.year;
                            month_or_week = nowComponents.month;
                            day = segment;
                            break;

                        default:
                            isValidDate = NO;
                    } //switch(num_leading_hyphens) (2 digits)
                    break;

                case 7: //YYYY DDD (ordinal date)
                    if (num_leading_hyphens &gt; 0U)
                        isValidDate = NO;
                    else {
                        day = segment % 1000U;
                        year = segment / 1000U;
                        dateSpecification = dateOnly;
                        if (strict &amp;&amp; (day &gt; (365U + is_leap_year(year))))
                            isValidDate = NO;
                    }
                    break;

                case 3: //--DDD (ordinal date, implicit year)
                    //Technically, the standard only allows one hyphen. But it says that two hyphens is the logical implementation, and one was dropped for brevity. So I have chosen to allow the missing hyphen.
                    if ((num_leading_hyphens &lt; 1U) || ((num_leading_hyphens &gt; 2U) &amp;&amp; !strict))
                        isValidDate = NO;
                    else {
                        day = segment;
                        year = nowComponents.year;
                        dateSpecification = dateOnly;
                        if (strict &amp;&amp; (day &gt; (365U + is_leap_year(year))))
                            isValidDate = NO;
                    }
                    break;

                default:
                    isValidDate = NO;
            }
        }

        if (isValidDate) {
            if (isspace(*ch) || (*ch == 'T')) ++ch;

            if (isdigit(*ch)) {
                hour = read_segment_2digits(ch, &amp;ch);
                if (*ch == timeSep) {
                    ++ch;
                    if ((timeSep == ',') || (timeSep == '.')) {
                        //We can't do fractional minutes when '.' is the segment separator.
                        //Only allow whole minutes and whole seconds.
                        minute = read_segment_2digits(ch, &amp;ch);
                        if (*ch == timeSep) {
                            ++ch;
                            second = read_segment_2digits(ch, &amp;ch);
                        }
                    } else {
                        //Allow a fractional minute.
                        //If we don't get a fraction, look for a seconds segment.
                        //Otherwise, the fraction of a minute is the seconds.
                        minute = read_double(ch, &amp;ch);
                        second = modf(minute, &amp;minute);
                        if (second &gt; DBL_EPSILON)
                            second *= 60.0; //Convert fraction (e.g. .5) into seconds (e.g. 30).
                        else if (*ch == timeSep) {
                            ++ch;
                            second = read_double(ch, &amp;ch);
                        }
                    }
                }

                if (!strict) {
                    if (isspace(*ch)) ++ch;
                }

                switch(*ch) {
                    case 'Z':
                        timeZone = [NSTimeZone timeZoneWithAbbreviation:@"UTC"];
                        break;

                    case '+':
                    case '-':;
                        BOOL negative = (*ch == '-');
                        if (isdigit(*++ch)) {
                            //Read hour offset.
                            segment = *ch - '0';
                            if (isdigit(*++ch)) {
                                segment *= 10U;
                                segment += *(ch++) - '0';
                            }
                            tz_hour = (NSInteger)segment;
                            if (negative) tz_hour = -tz_hour;

                            //Optional separator.
                            if (*ch == timeSep) ++ch;

                            if (isdigit(*ch)) {
                                //Read minute offset.
                                segment = *ch - '0';
                                if (isdigit(*++ch)) {
                                    segment *= 10U;
                                    segment += *ch - '0';
                                }
                                tz_minute = segment;
                                if (negative) tz_minute = -tz_minute;
                            }

                            NSInteger timeZoneOffset = (tz_hour * 3600) + (tz_minute * 60);
                            NSNumber *offsetNum = [NSNumber numberWithInteger:timeZoneOffset];
                            timeZone = [timeZonesByOffset objectForKey:offsetNum];
                            if (!timeZone) {
                                timeZone = [NSTimeZone timeZoneForSecondsFromGMT:timeZoneOffset];
                                if (timeZone)
                                    [timeZonesByOffset setObject:timeZone forKey:offsetNum];
                            }
                        }
                }
            }
        }

        if (isValidDate) {
            components.year = year;
            components.day = day;
            components.hour = hour;
            components.minute = (NSInteger)minute;
            components.second = (NSInteger)second;

            switch(dateSpecification) {
                case monthAndDate:
                    components.month = month_or_week;
                    break;

                case week:;
                    //Adapted from &lt;http://personal.ecu.edu/mccartyr/ISOwdALG.txt&gt;.
                    //This works by converting the week date into an ordinal date, then letting the next case handle it.
                    NSUInteger prevYear = year - 1U;
                    NSUInteger YY = prevYear % 100U;
                    NSUInteger C = prevYear - YY;
                    NSUInteger G = YY + YY / 4U;
                    NSUInteger isLeapYear = (((C / 100U) % 4U) * 5U);
                    NSUInteger Jan1Weekday = (isLeapYear + G) % 7U;
                    enum { monday, tuesday, wednesday, thursday/*, friday, saturday, sunday*/ };
                    components.day = ((8U - Jan1Weekday) + (7U * (Jan1Weekday &gt; thursday))) + (day - 1U) + (7U * (month_or_week - 2));

                case dateOnly: //An "ordinal date".
                    break;
            }
        }
    } //if (!(strict &amp;&amp; isdigit(ch[0])))

    if (outRange) {
        if (isValidDate)
            range.length = ch - start_of_date;
        else
            range.location = NSNotFound;

        *outRange = range;
    }
    if (outTimeZone) {
        *outTimeZone = timeZone;
    }

    return components;
}

- (NSDate *) dateFromString:(NSString *)string {
    return [self dateFromString:string timeZone:NULL];
}
- (NSDate *) dateFromString:(NSString *)string timeZone:(out NSTimeZone **)outTimeZone {
    return [self dateFromString:string timeZone:outTimeZone range:NULL];
}
- (NSDate *) dateFromString:(NSString *)string timeZone:(out NSTimeZone **)outTimeZone range:(out NSRange *)outRange {
    NSTimeZone *timeZone = nil;
    NSDateComponents *components = [self dateComponentsFromString:string timeZone:&amp;timeZone range:outRange];
    if (outTimeZone)
        *outTimeZone = timeZone;
    parsingCalendar.timeZone = timeZone;

    return [parsingCalendar dateFromComponents:components];
}

- (BOOL)getObjectValue:(id *)outValue forString:(NSString *)string errorDescription:(NSString **)error {
    NSDate *date = [self dateFromString:string];
    if (outValue)
        *outValue = date;
    return (date != nil);
}

#pragma mark Unparsing

@synthesize format;
@synthesize includeTime;
@synthesize timeSeparator;

- (NSString *) replaceColonsInString:(NSString *)timeFormat withTimeSeparator:(unichar)timeSep {
    if (timeSep != ':') {
        NSMutableString *timeFormatMutable = [[timeFormat mutableCopy] autorelease];
        [timeFormatMutable replaceOccurrencesOfString:@":"
                                           withString:[NSString stringWithCharacters:&amp;timeSep length:1U]
                                              options:NSBackwardsSearch | NSLiteralSearch
                                                range:(NSRange){ 0UL, [timeFormat length] }];
        timeFormat = timeFormatMutable;
    }
    return timeFormat;
}

- (NSString *) stringFromDate:(NSDate *)date {
    NSTimeZone *timeZone = self.defaultTimeZone;
    if (!timeZone) timeZone = [NSTimeZone defaultTimeZone];
    return [self stringFromDate:date timeZone:timeZone];
}

- (NSString *) stringFromDate:(NSDate *)date timeZone:(NSTimeZone *)timeZone {
    switch (self.format) {
        case ISO8601DateFormatCalendar:
            return [self stringFromDate:date formatString:ISO_CALENDAR_DATE_FORMAT timeZone:timeZone];
        case ISO8601DateFormatWeek:
            return [self weekDateStringForDate:date timeZone:timeZone];
        case ISO8601DateFormatOrdinal:
            return [self stringFromDate:date formatString:ISO_ORDINAL_DATE_FORMAT timeZone:timeZone];
        default:
            [NSException raise:NSInternalInconsistencyException format:@"self.format was %d, not calendar (%d), week (%d), or ordinal (%d)", self.format, ISO8601DateFormatCalendar, ISO8601DateFormatWeek, ISO8601DateFormatOrdinal];
            return nil;
    }
}

- (NSString *) stringFromDate:(NSDate *)date formatString:(NSString *)dateFormat timeZone:(NSTimeZone *)timeZone {
    if (includeTime)
        dateFormat = [dateFormat stringByAppendingFormat:@"'T'%@", [self replaceColonsInString:ISO_TIME_FORMAT withTimeSeparator:self.timeSeparator]];

    unparsingCalendar.timeZone = timeZone;

    if (dateFormat != lastUsedFormatString) {
        [unparsingFormatter release];
        unparsingFormatter = nil;

        [lastUsedFormatString release];
        lastUsedFormatString = [dateFormat retain];
    }

    if (!unparsingFormatter) {
        unparsingFormatter = [[NSDateFormatter alloc] init];
        unparsingFormatter.formatterBehavior = NSDateFormatterBehavior10_4;
        unparsingFormatter.dateFormat = dateFormat;
        unparsingFormatter.calendar = unparsingCalendar;
    }

    NSString *str = [unparsingFormatter stringForObjectValue:date];

    if (includeTime) {
        NSInteger offset = [timeZone secondsFromGMT];
        offset /= 60;  //bring down to minutes
        if (offset == 0)
            str = [str stringByAppendingString:ISO_TIMEZONE_UTC_FORMAT];
        else
            str = [str stringByAppendingFormat:ISO_TIMEZONE_OFFSET_FORMAT, offset / 60, offset % 60];
    }

    //Undo the change we made earlier
    unparsingCalendar.timeZone = self.defaultTimeZone;

    return str;
}

- (NSString *) stringForObjectValue:(id)value {
    NSParameterAssert([value isKindOfClass:[NSDate class]]);

    return [self stringFromDate:(NSDate *)value];
}

/*Adapted from:
 *      Algorithm for Converting Gregorian Dates to ISO 8601 Week Date
 *      Rick McCarty, 1999
 *      http://personal.ecu.edu/mccartyr/ISOwdALG.txt
 */
- (NSString *) weekDateStringForDate:(NSDate *)date timeZone:(NSTimeZone *)timeZone {
    unparsingCalendar.timeZone = timeZone;
    NSDateComponents *components = [unparsingCalendar components:NSYearCalendarUnit | NSWeekdayCalendarUnit | NSDayCalendarUnit fromDate:date];

    //Determine the ordinal date.
    NSDateComponents *startOfYearComponents = [unparsingCalendar components:NSYearCalendarUnit fromDate:date];
    startOfYearComponents.month = 1;
    startOfYearComponents.day = 1;
    NSDateComponents *ordinalComponents = [unparsingCalendar components:NSDayCalendarUnit fromDate:[unparsingCalendar dateFromComponents:startOfYearComponents] toDate:date options:0];
    ordinalComponents.day += 1;

    enum {
        monday, tuesday, wednesday, thursday, friday, saturday, sunday
    };
    enum {
        january = 1, february, march,
        april, may, june,
        july, august, september,
        october, november, december
    };

    NSInteger year = components.year;
    NSInteger week = 0;
    //The old unparser added 6 to [calendarDate dayOfWeek], which was zero-based; components.weekday is one-based, so we now add only 5.
    NSInteger dayOfWeek = (components.weekday + 5) % 7;
    NSInteger dayOfYear = ordinalComponents.day;

    NSInteger prevYear = year - 1;

    BOOL yearIsLeapYear = is_leap_year(year);
    BOOL prevYearIsLeapYear = is_leap_year(prevYear);

    NSInteger YY = prevYear % 100;
    NSInteger C = prevYear - YY;
    NSInteger G = YY + YY / 4;
    NSInteger Jan1Weekday = (((((C / 100) % 4) * 5) + G) % 7);

    NSInteger weekday = ((dayOfYear + Jan1Weekday) - 1) % 7;

    if((dayOfYear &lt;= (7 - Jan1Weekday)) &amp;&amp; (Jan1Weekday &gt; thursday)) {
        week = 52 + ((Jan1Weekday == friday) || ((Jan1Weekday == saturday) &amp;&amp; prevYearIsLeapYear));
        --year;
    } else {
        NSInteger lengthOfYear = 365 + yearIsLeapYear;
        if((lengthOfYear - dayOfYear) &lt; (thursday - weekday)) {
            ++year;
            week = 1;
        } else {
            NSInteger J = dayOfYear + (sunday - weekday) + Jan1Weekday;
            week = J / 7 - (Jan1Weekday &gt; thursday);
        }
    }

    NSString *timeString;
    if(includeTime) {
        NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
        unichar timeSep = self.timeSeparator;
        if (!timeSep) timeSep = ISO8601DefaultTimeSeparatorCharacter;
        formatter.dateFormat = [self replaceColonsInString:ISO_TIME_WITH_TIMEZONE_FORMAT withTimeSeparator:timeSep];

        timeString = [formatter stringForObjectValue:date];

        [formatter release];
    } else
        timeString = @"";

    return [NSString stringWithFormat:@"%lu-W%02lu-%02lu%@", (unsigned long)year, (unsigned long)week, ((unsigned long)dayOfWeek) + 1U, timeString];
}

@end

static NSUInteger read_segment(const unsigned char *str, const unsigned char **next, NSUInteger *out_num_digits) {
    NSUInteger num_digits = 0U;
    NSUInteger value = 0U;

    while(isdigit(*str)) {
        value *= 10U;
        value += *str - '0';
        ++num_digits;
        ++str;
    }

    if (next) *next = str;
    if (out_num_digits) *out_num_digits = num_digits;

    return value;
}
static NSUInteger read_segment_4digits(const unsigned char *str, const unsigned char **next, NSUInteger *out_num_digits) {
    NSUInteger num_digits = 0U;
    NSUInteger value = 0U;

    if (isdigit(*str)) {
        value += *(str++) - '0';
        ++num_digits;
    }

    if (isdigit(*str)) {
        value *= 10U;
        value += *(str++) - '0';
        ++num_digits;
    }

    if (isdigit(*str)) {
        value *= 10U;
        value += *(str++) - '0';
        ++num_digits;
    }

    if (isdigit(*str)) {
        value *= 10U;
        value += *(str++) - '0';
        ++num_digits;
    }

    if (next) *next = str;
    if (out_num_digits) *out_num_digits = num_digits;

    return value;
}
static NSUInteger read_segment_2digits(const unsigned char *str, const unsigned char **next) {
    NSUInteger value = 0U;

    if (isdigit(*str))
        value += *str - '0';

    if (isdigit(*++str)) {
        value *= 10U;
        value += *(str++) - '0';
    }

    if (next) *next = str;

    return value;
}

//strtod doesn't support ',' as a separator. This does.
static double read_double(const unsigned char *str, const unsigned char **next) {
    double value = 0.0;

    if (str) {
        NSUInteger int_value = 0;

        while(isdigit(*str)) {
            int_value *= 10U;
            int_value += (*(str++) - '0');
        }
        value = int_value;

        if (((*str == ',') || (*str == '.'))) {
            ++str;

            register double multiplier, multiplier_multiplier;
            multiplier = multiplier_multiplier = 0.1;

            while(isdigit(*str)) {
                value += (*(str++) - '0') * multiplier;
                multiplier *= multiplier_multiplier;
            }
        }
    }

    if (next) *next = str;

    return value;
}

static BOOL is_leap_year(NSUInteger year) {
    return \
    ((year %   4U) == 0U)
    &amp;&amp; (((year % 100U) != 0U)
        ||  ((year % 400U) == 0U));
}
</code></pre>

<h2>用法</h2>

<pre><code>ISO8601DateFormatter *dateFormat = [[[ISO8601DateFormatter alloc] init] autorelease];
NSDate *serverTime = [dateFormat dateFromString:dateTime];
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Shecha Touch实例学习]]></title>
    <link href="http://marukulau.github.io/blog/2012/12/19/sdf/"/>
    <updated>2012-12-19T15:38:00+08:00</updated>
    <id>http://marukulau.github.io/blog/2012/12/19/sdf</id>
    <content type="html"><![CDATA[<p>通过前几篇文章的介绍，大家应该对Sencha Touch总体有了了解，现在已经可以开始做一些简单的应用。这一次我们要做的是一个简单通讯录应用。</p>

<!-- more -->


<h2>原型图</h2>

<p>开始工作之前我们先把思路整理一下，最好能先把原型图画一下。</p>

<h2>开始编码</h2>

<ul>
<li>创建名为AddressBook的Sencha Touch项目。</li>
<li>把准备好联系人数据文件contacts.json拷贝到项目根目录下。</li>
<li>修改app.json配置文件。</li>
</ul>


<p>缓存：</p>

<pre><code>"appCache": {
    /**
     * List of items in the CACHE MANIFEST section
     */
    "cache": [
        "index.html",
        "contacts.json" //加入新增的数据文件
    ],
</code></pre>

<p>资源：</p>

<pre><code> /**
 * Extra resources to be copied along when build
 */
"resources": [
    "contacts.json", //加入新增的数据文件
    "resources/images",
    "resources/icons",
    "resources/startup"
],
</code></pre>

<h3>修改app/view/Main.js文件</h3>

<pre><code>Ext.define('AddressBook.view.Main', {
    extend: 'Ext.navigation.View',
    xtype: 'mainview', //自定义xtype
    config: {
        scrollable: 'vertical',
        items: [
            {
                xtype: 'list',
                title: 'Contacts', //设置navigationView的title
                id: 'contact-list',
                itemTpl: [
                    '&lt;div&gt;&lt;img src=\'\' /&gt; {firstName}&amp;nbsp;{lastName}&lt;/div&gt;' //自定义list cell的模版
                ],
                store: 'contacts', //指定数据仓库
                grouped: true,
                indexBar: true
            }
        ]
    }

});
</code></pre>

<p>由于我们需要点击该列表进入对应的联系人详情页，所以应该选择navigation控件，把Main类的父类设为navigation.View:<code>extend: 'Ext.navigation.View'</code>。</p>

<h3>新建app/store/contacts.js和app/model/ContactModel.js文件</h3>

<p><em>contacts.js：</em></p>

<pre><code>Ext.define('AddressBook.store.contacts', {
    extend: 'Ext.data.Store',

    requires: [
        'AddressBook.model.ContactModel'
    ],

    config: {
        autoLoad: true,
        model: 'AddressBook.model.ContactModel',
        remoteSort: false,
        storeId: 'contacts',
        proxy: {
            type: 'ajax',
            url: 'contacts.json'
        },
        sorters: 'firstName',
        grouper: {
            groupFn: function(record) {
                return record.get('lastName')[0];
            }
        }

    }
});
</code></pre>

<p><em>ContactModel.js：</em></p>

<pre><code>Ext.define('AddressBook.model.ContactModel', {
    extend: 'Ext.data.Model',

    config: {
        fields: [
            'firstName',
            'lastName',
            'title'
        ]
    }
});
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Sencha Touch 2.1进行iOS开发 —— 项目文件结构及代码分析]]></title>
    <link href="http://marukulau.github.io/blog/2012/12/19/shi-yong-sencha-touch-2-dot-1jin-xing-ioskai-fa-xiang-mu-wen-jian-ji-jie-gou-fen-xi/"/>
    <updated>2012-12-19T09:20:00+08:00</updated>
    <id>http://marukulau.github.io/blog/2012/12/19/shi-yong-sencha-touch-2-dot-1jin-xing-ioskai-fa-xiang-mu-wen-jian-ji-jie-gou-fen-xi</id>
    <content type="html"><![CDATA[<p>从第一篇文章我们知道了如何通过sencha命令创建Sencha Touch项目，而创建的项目里面已经包含了不少文件，如要开始写代码，我们有必要先了解所创建项目的文件结构及代码。</p>

<!-- more -->


<h2>文件结构</h2>

<p>在终端输入</p>

<pre><code>$ sencha generate app HelloWorld ~/Desktop/HelloWorld
</code></pre>

<p>我们创建了一个名为HelloWorld的项目，进入该文件夹可以看到文件如下：</p>

<pre><code>app/
    controller/
    model/
    profile/
    store/
    view/
        Main.js
app.js
app.json
build.xml
index.html
packager.json
resources/
touch/
</code></pre>

<ul>
<li>packager.json 一些sencha package命令要用到的文件，里面是一些编译打包配置信息。</li>
<li>app.js 包含了应用的初始化逻辑代码。</li>
<li>app.json 应用部署的配置。</li>
<li>app/ MVC结构的应用源代码文件。</li>
<li>resources/ 资源文件夹。</li>
<li>touch/ Sencha Touch SDK文件。</li>
</ul>


<h2>代码分析</h2>

<h3>应用入口</h3>

<p>app.js是应用的初始化文件，也就是意味着应用的入口在这里，打开该文件，我可以看到这一段代码：</p>

<pre><code>launch: function() {
    // Destroy the #appLoadingIndicator element
    Ext.fly('appLoadingIndicator').destroy();

    // Initialize the main view
    Ext.Viewport.add(Ext.create('HelloWorld.view.Main'));
},
</code></pre>

<p><code>Ext.create('HelloWorld.view.Main')</code>创建了一个HelloWorld.view.Main实例并加入到Viewport中，也就是说我们进入应用看到的主界面的代码源文件是app/view/Main.js文件。</p>

<h2>xtype</h2>

<p>打开Main.js文件，上一篇文章已经讲过类的定义了，所以HelloWorld.view.Main类的定义应该比较好理解。需要注意的是里面的<code>xtype: 'main'</code>属性，这个是定义当前类的xtype，方便被其他类用进行引用，而config下items的xtype则是对其他已定义xtype的类的引用。</p>

<p>下面是SDK所有的xtype及其对应的类：</p>

<pre><code>xtype                   Class
-----------------       ---------------------
actionsheet             Ext.ActionSheet
audio                   Ext.Audio
button                  Ext.Button
component               Ext.Component
container               Ext.Container
image                   Ext.Img
label                   Ext.Label
loadmask                Ext.LoadMask
map                     Ext.Map
mask                    Ext.Mask
media                   Ext.Media
panel                   Ext.Panel
segmentedbutton         Ext.SegmentedButton
sheet                   Ext.Sheet
spacer                  Ext.Spacer
title                   Ext.Title
titlebar                Ext.TitleBar
toolbar                 Ext.Toolbar
video                   Ext.Video
carousel                Ext.carousel.Carousel
carouselindicator       Ext.carousel.Indicator
navigationview          Ext.navigation.View
datepicker              Ext.picker.Date
picker                  Ext.picker.Picker
pickerslot              Ext.picker.Slot
slider                  Ext.slider.Slider
thumb                   Ext.slider.Thumb
tabbar                  Ext.tab.Bar
tabpanel                Ext.tab.Panel
tab                     Ext.tab.Tab
viewport                Ext.viewport.Default

DataView Components
---------------------------------------------
dataview                Ext.dataview.DataView
list                    Ext.dataview.List
listitemheader          Ext.dataview.ListItemHeader
nestedlist              Ext.dataview.NestedList
dataitem                Ext.dataview.component.DataItem

Form Components
---------------------------------------------
checkboxfield           Ext.field.Checkbox
datepickerfield         Ext.field.DatePicker
emailfield              Ext.field.Email
field                   Ext.field.Field
hiddenfield             Ext.field.Hidden
input                   Ext.field.Input
numberfield             Ext.field.Number
passwordfield           Ext.field.Password
radiofield              Ext.field.Radio
searchfield             Ext.field.Search
selectfield             Ext.field.Select
sliderfield             Ext.field.Slider
spinnerfield            Ext.field.Spinner
textfield               Ext.field.Text
textareafield           Ext.field.TextArea
textareainput           Ext.field.TextAreaInput
togglefield             Ext.field.Toggle
urlfield                Ext.field.Url
fieldset                Ext.form.FieldSet
formpanel               Ext.form.Panel
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Sencha Touch 2.1进行iOS开发 —— 类的定义与使用]]></title>
    <link href="http://marukulau.github.io/blog/2012/12/18/shi-yong-sencha-touch-2-dot-1jin-xing-ioskai-fa-lei-ding-yi/"/>
    <updated>2012-12-18T13:57:00+08:00</updated>
    <id>http://marukulau.github.io/blog/2012/12/18/shi-yong-sencha-touch-2-dot-1jin-xing-ioskai-fa-lei-ding-yi</id>
    <content type="html"><![CDATA[<h2>类的定义</h2>

<p>Sencha Touch有自己的类定义方式，我们先来看个例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="s1">&#39;Animal&#39;</span><span class="p">,</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">config</span><span class="o">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">name</span><span class="o">:</span> <span class="kc">null</span>
</span><span class='line'>    <span class="p">},</span>
</span><span class='line'>
</span><span class='line'>    <span class="nx">constructor</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">this</span><span class="p">.</span><span class="nx">initConfig</span><span class="p">(</span><span class="nx">config</span><span class="p">);</span>
</span><span class='line'>    <span class="p">},</span>
</span><span class='line'>
</span><span class='line'>    <span class="nx">speak</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">alert</span><span class="p">(</span><span class="s1">&#39;grunt&#39;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面我们简单地定义了一个Animal类，只有一个name属性和一个方法speak();</p>

<!-- more -->


<h2>类的继承</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="s1">&#39;Human&#39;</span><span class="p">,</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">extend</span><span class="o">:</span> <span class="s1">&#39;Animal&#39;</span><span class="p">,</span>
</span><span class='line'>
</span><span class='line'>    <span class="nx">speak</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">getName</span><span class="p">());</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>
我们定义了一个Human类继承自Animal，并重写speak()方法。</p>

<h2>类的实例化</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">bob</span> <span class="o">=</span> <span class="nx">Ext</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="s1">&#39;Human&#39;</span><span class="p">,</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;Bob&#39;</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="nx">bob</span><span class="p">.</span><span class="nx">speak</span><span class="p">();</span> <span class="c1">//alerts &#39;Bob&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>
通过Ext.create()静态方法创建类实例。</p>

<h2>getter和setter方法</h2>

<p>对应的属性会自动生成getter和setter方法，如上面继承的例子中的this.getName()，setter方法为：this.setName(&lsquo;&rsquo;)。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="s1">&#39;Human&#39;</span><span class="p">,</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">extend</span><span class="o">:</span> <span class="s1">&#39;Animal&#39;</span><span class="p">,</span>
</span><span class='line'>
</span><span class='line'>    <span class="nx">applyName</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">newName</span><span class="p">,</span> <span class="nx">oldName</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nx">confirm</span><span class="p">(</span><span class="s1">&#39;Are you sure you want to change name to &#39;</span> <span class="o">+</span> <span class="nx">newName</span> <span class="o">+</span> <span class="s1">&#39;?&#39;</span><span class="p">)</span><span class="o">?</span> <span class="nx">newName</span> <span class="o">:</span> <span class="nx">oldName</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>
applyName()方法是在调用setter方法后自动回调的方法，上面例子将在调用setter方法后弹出确认窗口询问是否修改name的值，点击no的话则不进行修改。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="s1">&#39;Human&#39;</span><span class="p">,</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">extend</span><span class="o">:</span> <span class="s1">&#39;Animal&#39;</span><span class="p">,</span>
</span><span class='line'>
</span><span class='line'>    <span class="nx">updateName</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">newName</span><span class="p">,</span> <span class="nx">oldName</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">alert</span><span class="p">(</span><span class="s1">&#39;Name changed. New name is: &#39;</span> <span class="o">+</span> <span class="nx">newName</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>
updateName()方法则是在调用setter方法后并且改属性值已经修改了的情况下自动回调的。</p>

<h2>依赖和动态加载</h2>

<p>有时候我们需要在类里面使用某个类的，这时候我们需要加入这个类的引用声明：requires: &lsquo;Ext.MessageBox&#8217;。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="s1">&#39;Human&#39;</span><span class="p">,</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">extend</span><span class="o">:</span> <span class="s1">&#39;Animal&#39;</span><span class="p">,</span>
</span><span class='line'>
</span><span class='line'>    <span class="nx">requires</span><span class="o">:</span> <span class="s1">&#39;Ext.MessageBox&#39;</span><span class="p">,</span>
</span><span class='line'>
</span><span class='line'>    <span class="nx">speak</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">Ext</span><span class="p">.</span><span class="nx">Msg</span><span class="p">.</span><span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">getName</span><span class="p">(),</span> <span class="s2">&quot;Speaks...&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>
加入引用声明后，Sencha Touch会自动判断是否Ext.MessageBox已经加载，如果未加载的话则会自动通过AJAX加载对应的类文件。</p>

<h2>命名空间</h2>

<p>以上一篇文章的Main.js文件为例</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="s1">&#39;HelloSenCha.view.Main&#39;</span><span class="p">,</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">extend</span><span class="o">:</span> <span class="s1">&#39;Ext.navigation.View&#39;</span><span class="p">,</span>
</span><span class='line'>    <span class="nx">xtype</span><span class="o">:</span> <span class="s1">&#39;mainview&#39;</span><span class="p">,</span>
</span><span class='line'>
</span><span class='line'>    <span class="nx">requires</span><span class="o">:</span> <span class="p">[</span>
</span><span class='line'>        <span class="s1">&#39;HelloSenCha.view.Contacts&#39;</span><span class="p">,</span>
</span><span class='line'>        <span class="s1">&#39;HelloSenCha.view.contact.Show&#39;</span><span class="p">,</span>
</span><span class='line'>        <span class="s1">&#39;HelloSenCha.view.contact.Edit&#39;</span>
</span><span class='line'>    <span class="p">],</span>
</span><span class='line'><span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>
类名规则为：项目名称.目录1.目录2&hellip;类名，也就是说，Main.js和Contacts.js文件在view文件夹下，Show.js和Edit.js在view/contact文件夹下。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Sencha Touch 2.1进行iOS开发 —— 开发环境搭建]]></title>
    <link href="http://marukulau.github.io/blog/2012/12/14/shi-yong-sencha-touch-2-dot-1jin-xing-ioskai-fa-kai-fa-huan-jing-da-jian/"/>
    <updated>2012-12-14T15:36:00+08:00</updated>
    <id>http://marukulau.github.io/blog/2012/12/14/shi-yong-sencha-touch-2-dot-1jin-xing-ioskai-fa-kai-fa-huan-jing-da-jian</id>
    <content type="html"><![CDATA[<p>最近由于要用到Sencha Touch 2.1进行项目的开发，于是开始了对Sencha Touch的学习，学习Sencha Touch第一步当然是搭建开发环境。</p>

<h2>开发环境搭建</h2>

<h3>Sencha iOS开发基本环境</h3>

<ul>
<li>Mac OSX</li>
<li>Xcode</li>
<li>Sencha Touch SDK</li>
</ul>


<!-- more -->


<h3>Sencha Touch SDK下载</h3>

<p>开发环境搭建的第一步当然就是下载SDK，Sencha Touch 2.1的SDK可以到官网下载：<a href="http://www.sencha.com/products/touch/download/">下载页面</a>, 这里需要填个邮箱地址，随便填一个地址就可以了，会自动跳转到下载页面。</p>

<h3>创建Sencha iOS项目</h3>

<p>SDk下载好了之后就可以通过PhoneGap或者直接自己建个项目在webView里面加载Sencha页面就可以了。事实上还有第三种方法，就是Sencha Cmd，官方对Sencha Cmd的介绍是：</p>

<blockquote><p>Sencha Cmd is a cross-platform command line tool that provides many automated tasks around the full life-cycle of your applications, from generating a new project to deploying an application to production.</p></blockquote>

<p>也就是说，我们可以直接使用Sencha Cmd这个工具进行全生命周期的应用开发。另外，官网还有个Sencha SDK Tools，不过官网也建议：</p>

<blockquote><p>Please note: Sencha SDK Tools are designed to be used with Sencha Touch 2 and Ext JS 4.0 and are deprecated for the most current framework releases. For the current version of Sencha’s build tools, please refer to Sencha Cmd, our unified tool for Sencha’s JavaScript frameworks.</p></blockquote>

<p>所以还是老老实实下载Sencha Cmd吧，Sencha Cmd <a href="http://www.sencha.com/products/sencha-cmd/download">下载地址</a>。</p>

<p>下载后安装好就可以打开终端敲命令进行创建Sencha项目了，我们把项目创建在桌面，项目名称为HelloSencha，命令如下：</p>

<pre><code>$ sencha generate app HelloSenCha ~/Desktop/HelloSenCha

Sencha Cmd v3.0.0.250
[INF]       init-properties:
[INF]       init-sencha-command:
[INF]       init:
[INF]       -before-generate-workspace:
[INF]       generate-workspace-impl:
[WRN]       Ignoring @require ../version/Version.js in js/String.js
[WRN]       Ignoring @require ../Ext-more.js in js/Format.js
[INF]       -before-copy-framework-to-workspace:
[INF]       copy-framework-to-workspace-impl:
</code></pre>

<p>等命令执行完毕后，到桌面就可以看到创建好的项目了。</p>

<h3>编译项目</h3>

<p>无需通过Xcode，我们就可以直接执行命令进行编译，编译结果将放在../build 文件夹下。</p>

<pre><code>$ sencha package build ~/Desktop/HelloSenCha/packager.json
</code></pre>

<h3>运行项目</h3>

<p>同样，我们无需打开Xcode，直接通过命令就可以把我们刚才创建的项目在iOS模拟器里面运行起来：</p>

<pre><code>$ sencha package run ~/Desktop/HelloSenCha/packager.json
</code></pre>

<p>现在，我们已经知道了怎么创建、编译和部署项目了，接下来就可以进行Sencha Touch SDK的学习了。</p>
]]></content>
  </entry>
  
</feed>
